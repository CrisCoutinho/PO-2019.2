# -*- coding: utf-8 -*-
"""BucketSort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HEEYd1leWON-OMCB2_0PU8m01uLJkFdY
"""

import numpy as np
from random import shuffle, randint
import timeit
import matplotlib as mpl
import matplotlib.pyplot as plt
import sys
import math

mpl.use('Agg')
mpl.rc('lines', linewidth=2.9)
plt.style.use('ggplot')

sys.setrecursionlimit(10**7) 



  
def bucketSortWithCountingSort(array):
    code = hashing(array)
    buckets = [list() for _ in range( code[1] )]
    for i in array:
        x = re_hashing( i, code )
        buck = buckets[x]
        buck.append( i )
    for bucket in buckets:
        countingSort(bucket)
         
    ndx = 0
    for b in range( len( buckets ) ):
        for v in buckets[b]:
            array[ndx] = v
            ndx += 1
    
    return array



def countingSort(lista):   #Complexidade Temporal = O(n+k), n para numero de elementos e k o tamanho da lista
  k = max(lista)
  B = [0 for w in range(len(lista))]
  C = [0 for w in range(k+1)]
  for j in range(0,len(lista)):
    C[lista[j]] = C[lista[j]] + 1
  for i in range(1,k+1):
    C[i] += C[i-1]
  for j in range(len(lista)-1,0,-1):
    B[C[lista[j]]-1] = lista[j]
    C[lista[j]] = C[lista[j]] - 1
  return B

#~~~~~~~~~~BucketSort with quickSort~~~~~~~~~~#

def bucketSortWithQuickSort(array):
    code = hashing(array)
    buckets = [list() for _ in range( code[1] )]
    for i in array:
        x = re_hashing( i, code )
        buck = buckets[x]
        buck.append( i )
    for bucket in buckets:
        startingQuickSort(bucket)
         
    ndx = 0
    for b in range( len( buckets ) ):
        for v in buckets[b]:
            array[ndx] = v
            ndx += 1
    
    return array

def partitionForQuickSort(newList,startIndex,endIndex): 
    i = ( startIndex-1 )         
    pivot = randint(startIndex, endIndex) 
  
    for j in range(startIndex , endIndex): 
  
        if   newList[j] <= pivot: 
          
            i = i+1 
            newList[i],newList[j] = newList[j],newList[i] 
  
    newList[i+1],newList[endIndex] = newList[endIndex],newList[i+1] 
    return ( i+1 ) 

def quickSort(newList,startIndex,endIndex): 
  
    if startIndex < endIndex: 
  
        pivot = partitionForQuickSort(newList,startIndex,endIndex) 

        quickSort(newList, startIndex, pivot-1) 
        quickSort(newList, pivot+1, endIndex) 
        
def startingQuickSort(newList):
  quickSort(newList, 0, len(newList) -1)
  
  
#~~~~~~~~~~~~BucketSort with mergeSort~~~~~~~~~~~#

def bucketSortWithMergeSort(array):
    code = hashing(array)
    buckets = [list() for _ in range( code[1] )]
    for i in array:
        x = re_hashing( i, code )
        buck = buckets[x]
        buck.append( i )
    for bucket in buckets:
        startingMergeSort(bucket)
         
    ndx = 0
    for b in range( len( buckets ) ):
        for v in buckets[b]:
            array[ndx] = v
            ndx += 1
    
    return array

def startingMergeSort(elementList):
	mergeSort(elementList, 0, len(elementList)-1)
	
def mergeSort(elementList, first, last):
	if first < last:
		middle = (first + last)//2
		mergeSort(elementList, first, middle)
		mergeSort(elementList, middle+1, last)
		merging(elementList, first, middle, last)
		
def merging(elementList, first, middle, last):
	L = elementList[first:middle+1]
	R = elementList[middle+1:last+1]
	L.append(sys.maxsize)
	R.append(sys.maxsize)
	i = j = 0
	
	for k in range (first, last+1):
		if L[i] <= R[j]:
			elementList[k] = L[i]
			i += 1
		else:
			elementList[k] = R[j]
			j += 1

      
def hashing(array):
    m = array[0]
    for i in range(1, len(array)):
        if ( m < array[i] ):
            m = array[i]
    result = [m,int(math.sqrt( len(array)))]
    return result

  
def re_hashing(i, code ):
    return int(i/code[0]*(code[1]-1))      
      
      
def listInv(tamanho):
  lista =[]
  for i in range(tamanho, 0, -1):
    lista.append(tamanho)
    tamanho = tamanho - 1
  return lista


def drawGraph(x,y,yInv,XAxis = "Lista de Numeros", YAxis = "Tempo de ordenação", name =" Tempo de ordenação em seg"):
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111)
    plt.scatter(x,y,marker='^',facecolor='red',edgecolors= 'red', linewidths=4)  
    ax.plot(x,y,color = 'blue', markerfacecoloralt ='green', label = "Aleatorio")
    plt.scatter(x,yInv,marker= 'v',facecolor='blue',edgecolors= 'blue', linewidths=4)  
    ax.plot(x,yInv, color = 'red', label = "Invertida")
    ax.legend(bbox_to_anchor=(1, 1),bbox_transform=plt.gcf().transFigure)
    plt.ylabel(YAxis)
    plt.xlabel(XAxis)
    fig.savefig(name)
    plt.show()

def listInv(tamanho):
  newList =[]
  for i in range(tamanho, 0, -1):
    newList.append(tamanho)
    tamanho = tamanho - 1
  return newList


def generateList(tam):
  newList = list(range(1, tam + 1))
  shuffle(newList)
  return newList

#Casos testados:  100k, 200k, 300k, 400k, 500k, 1M e 2M 

listValueGraph = [100 ,200, 300 , 400, 500, 1000, 2000]
#~~~~~~~~~~ Tests ~~~~~~~~~~~#


value100k = 100000
value200k = 200000
value300k = 300000
value400k = 400000
value500k = 500000
value1M = 1000000
value2M = 2000000

#~~~~~~~~~~ List Inverted Case ~~~~~~~~~~~#

listInvertedCase100k = listInv(value100k)
listInvertedCase200k = listInv(value200k)
listInvertedCase300k = listInv(value300k)
listInvertedCase400k = listInv(value400k)
listInvertedCase500k = listInv(value500k)
listInvertedCase1M = listInv(value1M)
listInvertedCase2M = listInv(value2M)

listInvertedQS100k = listInvertedCase100k
listInvertedQS200k = listInvertedCase200k
listInvertedQS300k = listInvertedCase300k
listInvertedQS400k = listInvertedCase400k
listInvertedQS500k = listInvertedCase500k 
listInvertedQS1M = listInvertedCase1M 
listInvertedQS2M = listInvertedCase2M 

listInvertedMS100k = listInvertedCase100k
listInvertedMS200k = listInvertedCase200k
listInvertedMS300k = listInvertedCase300k
listInvertedMS400k = listInvertedCase400k
listInvertedMS500k = listInvertedCase500k 
listInvertedMS1M = listInvertedCase1M 
listInvertedMS2M = listInvertedCase2M 


listQuestionInvertedCase = [listInvertedCase100k,listInvertedCase200k,
                            listInvertedCase300k,listInvertedCase400k,
                            listInvertedCase500k,listInvertedCase1M, 
                            listInvertedCase2M]

timeSortInvertedCase = []

listQuestionInvertedQS = [listInvertedQS100k,listInvertedQS200k,
                            listInvertedQS300k,listInvertedQS400k,
                            listInvertedQS500k,listInvertedQS1M, 
                            listInvertedQS2M]
timeSortInvertedQS = []

listQuestionInvertedMS = [listInvertedMS100k,listInvertedMS200k,
                            listInvertedMS300k,listInvertedMS400k,
                            listInvertedMS500k,listInvertedMS1M, 
                            listInvertedMS2M]
timeSortInvertedMS = []

#~~~~~~~~~~ Random List Case ~~~~~~~~~~~#

listRandomCase100k = generateList(value100k)
listRandomCase200k = generateList(value200k)
listRandomCase300k = generateList(value300k)
listRandomCase400k = generateList(value400k)
listRandomCase500k = generateList(value500k)
listRandomCase1M = generateList(value1M)
listRandomCase2M = generateList(value2M)

listRandomQS100k = listRandomCase100k
listRandomQS200k = listRandomCase200k
listRandomQS300k = listRandomCase300k
listRandomQS400k = listRandomCase400k
listRandomQS500k = listRandomCase500k 
listRandomQS1M = listRandomCase1M 
listRandomQS2M = listRandomCase2M 

listRandomMS100k = listRandomCase100k
listRandomMS200k = listRandomCase200k
listRandomMS300k = listRandomCase300k
listRandomMS400k = listRandomCase400k
listRandomMS500k = listRandomCase500k 
listRandomMS1M = listRandomCase1M 
listRandomMS2M = listRandomCase2M


listQuestionRandomCase = [listRandomCase100k,listRandomCase200k,
                          listRandomCase300k,listRandomCase400k,
                          listRandomCase500k,listRandomCase1M,
                          listRandomCase2M] 
timeSortRandomCase = []

listQuestionRandomQS = [listRandomQS100k,listRandomQS200k,
                          listRandomQS300k,listRandomQS400k,
                          listRandomQS500k,listRandomQS1M,
                          listRandomQS2M]
timeSortRandomQS = []

listQuestionRandomMS = [listRandomMS100k,listRandomMS200k,
                          listRandomMS300k,listRandomMS400k,
                          listRandomMS500k,listRandomMS1M,
                          listRandomMS2M]
timeSortRandomMS = []

for i in range(7):
    timeSortInvertedCase.append(timeit.
                                timeit("bucketSortWithCountingSort({})".format(listQuestionInvertedCase[i]),
                                              setup="from __main__ import bucketSortWithCountingSort,countingSort, listInv, generateList",number = 1))
    timeSortRandomCase.append(timeit.
                              timeit("bucketSortWithCountingSort({})".format(listQuestionRandomCase[i]),
                                            setup="from __main__ import bucketSortWithCountingSort, countingSort, listInv, generateList",number = 1))
    timeSortInvertedQS.append(timeit.
                                timeit("bucketSortWithQuickSort({})".format(listQuestionInvertedQS[i]),
                                              setup="from __main__ import bucketSortWithQuickSort, startingQuickSort, quickSort,partitionForQuickSort, listInv, generateList",number = 1))
    timeSortRandomQS.append(timeit.
                              timeit("bucketSortWithQuickSort({})".format(listQuestionRandomQS[i]),
                                            setup="from __main__ import bucketSortWithQuickSort, startingQuickSort, quickSort,partitionForQuickSort, listInv, generateList",number = 1))
    timeSortInvertedMS.append(timeit.
                                timeit("bucketSortWithMergeSort({})".format(listQuestionInvertedMS[i]),
                                              setup="from __main__ import bucketSortWithMergeSort,startingMergeSort,mergeSort,merging, listInv, generateList",number = 1))
    timeSortRandomMS.append(timeit.
                              timeit("bucketSortWithMergeSort({})".format(listQuestionRandomMS[i]),
                                            setup="from __main__ import bucketSortWithMergeSort, startingMergeSort,mergeSort,merging, listInv, generateList",number = 1))
    
    print(i)

drawGraph(listValueGraph,
          timeSortInvertedCase,
          timeSortRandomCase, 
          XAxis="Número de elementos em milhares", 
          YAxis="Tempo de ordenação em Seg",
         name = "Tempo de ordenação em Seg BucketSort com CS")

drawGraph(listValueGraph,
          timeSortInvertedQS,
          timeSortRandomQS, 
          XAxis="Número de elementos em milhares", 
          YAxis="Tempo de ordenação em Seg",
         name = "Tempo de ordenação em Seg BucketSort com QS")

drawGraph(listValueGraph,
          timeSortInvertedMS,
          timeSortRandomMS, 
          XAxis="Número de elementos em milhares", 
          YAxis="Tempo de ordenação em Seg",
         name = "Tempo de ordenação em Seg BucketSort com MS")